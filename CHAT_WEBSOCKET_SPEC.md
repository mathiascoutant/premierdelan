# üîå Sp√©cification - WebSocket pour le Chat en Temps R√©el

## üìã Vue d'ensemble

Syst√®me de WebSocket pour la communication en temps r√©el entre admins, √©vitant le polling et r√©duisant drastiquement le nombre de requ√™tes.

---

## üéØ Avantages du WebSocket

- ‚úÖ **Temps r√©el** : Messages instantan√©s sans d√©lai
- ‚úÖ **Efficacit√©** : Pas de polling toutes les secondes
- ‚úÖ **Scalabilit√©** : R√©duit la charge serveur de 99%
- ‚úÖ **UX am√©lior√©e** : Exp√©rience fluide comme WhatsApp

---

## üîß Configuration Backend (Python Flask/FastAPI)

### Installation des d√©pendances

```bash
pip install websockets
```

### Code Backend (WebSocket Natif avec FastAPI)

**Note** : Le backend utilise WebSocket natif (pas Socket.IO) √† l'URL `/ws/chat`

```python
from flask import Flask
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_cors import CORS
import jwt

app = Flask(__name__)
CORS(app, origins=['http://localhost:3000', 'https://mathiascoutant.github.io'])
socketio = SocketIO(app, cors_allowed_origins=['http://localhost:3000', 'https://mathiascoutant.github.io'])

# Stockage des connexions actives
active_connections = {}  # {user_id: socket_id}

@socketio.on('connect')
def handle_connect():
    """Connexion d'un client WebSocket"""
    print(f"‚úÖ Client connect√©: {request.sid}")

@socketio.on('authenticate')
def handle_authenticate(data):
    """Authentification via JWT"""
    try:
        token = data.get('token')
        decoded = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        user_id = decoded['user_id']

        # Enregistrer la connexion
        active_connections[user_id] = request.sid

        # Joindre une room personnelle pour cet utilisateur
        join_room(f"user_{user_id}")

        print(f"‚úÖ Utilisateur {user_id} authentifi√©")
        emit('authenticated', {'success': True})

    except Exception as e:
        print(f"‚ùå Erreur d'authentification: {str(e)}")
        emit('error', {'message': 'Authentification √©chou√©e'})

@socketio.on('disconnect')
def handle_disconnect():
    """D√©connexion d'un client"""
    # Retirer de active_connections
    for user_id, sid in list(active_connections.items()):
        if sid == request.sid:
            del active_connections[user_id]
            print(f"‚ùå Utilisateur {user_id} d√©connect√©")
            break

@socketio.on('join_conversation')
def handle_join_conversation(data):
    """Rejoindre une conversation sp√©cifique"""
    conversation_id = data.get('conversation_id')
    join_room(f"conversation_{conversation_id}")
    print(f"üë§ Client a rejoint la conversation {conversation_id}")

@socketio.on('leave_conversation')
def handle_leave_conversation(data):
    """Quitter une conversation"""
    conversation_id = data.get('conversation_id')
    leave_room(f"conversation_{conversation_id}")
    print(f"üëã Client a quitt√© la conversation {conversation_id}")

@socketio.on('send_message')
def handle_send_message(data):
    """Recevoir un message du client et le diffuser"""
    conversation_id = data.get('conversation_id')
    message = data.get('message')
    sender_id = data.get('sender_id')

    # Diffuser le message √† tous les participants de la conversation
    emit('new_message', {
        'conversation_id': conversation_id,
        'message': message
    }, room=f"conversation_{conversation_id}", include_self=False)

    print(f"üí¨ Message diffus√© dans la conversation {conversation_id}")

# Fonction helper pour notifier un utilisateur sp√©cifique
def notify_user(user_id, event_name, data):
    """Envoie un √©v√©nement √† un utilisateur sp√©cifique"""
    if user_id in active_connections:
        socketio.emit(event_name, data, room=f"user_{user_id}")
        return True
    return False

# Exemple d'utilisation apr√®s avoir sauvegard√© un message en DB
def after_save_message(conversation_id, message_data, recipient_id):
    """Apr√®s avoir sauvegard√© un message, notifier via WebSocket"""
    # Notifier le destinataire du nouveau message
    notify_user(recipient_id, 'new_message', {
        'conversation_id': str(conversation_id),
        'message': message_data
    })

# Exemple d'utilisation apr√®s une invitation
def after_create_invitation(invitation_data, recipient_id):
    """Apr√®s avoir cr√©√© une invitation, notifier via WebSocket"""
    # Notifier le destinataire de la nouvelle invitation
    notify_user(recipient_id, 'new_invitation', {
        'invitation': invitation_data
    })
```

---

## üåê URL WebSocket

**URL de connexion** : `wss://believable-spontaneity-production.up.railway.app`

**Namespace** : `/chat` (optionnel)

**URL compl√®te** : `wss://believable-spontaneity-production.up.railway.app/socket.io/`

---

## üì° √âv√©nements WebSocket

### √âv√©nements Client ‚Üí Serveur

| √âv√©nement            | Description                | Donn√©es                                                         |
| -------------------- | -------------------------- | --------------------------------------------------------------- |
| `connect`            | Connexion initiale         | -                                                               |
| `authenticate`       | Authentification JWT       | `{token: string}`                                               |
| `join_conversation`  | Rejoindre une conversation | `{conversation_id: string}`                                     |
| `leave_conversation` | Quitter une conversation   | `{conversation_id: string}`                                     |
| `send_message`       | Envoyer un message         | `{conversation_id: string, message: object, sender_id: string}` |

### √âv√©nements Serveur ‚Üí Client

| √âv√©nement             | Description               | Donn√©es                                      |
| --------------------- | ------------------------- | -------------------------------------------- |
| `authenticated`       | Authentification r√©ussie  | `{success: true}`                            |
| `new_message`         | Nouveau message re√ßu      | `{conversation_id: string, message: object}` |
| `new_invitation`      | Nouvelle invitation re√ßue | `{invitation: object}`                       |
| `invitation_accepted` | Invitation accept√©e       | `{conversation: object}`                     |
| `error`               | Erreur                    | `{message: string}`                          |

---

## üíª Int√©gration dans les Endpoints

### POST `/api/admin/chat/conversations/:id/messages`

```python
@app.route('/api/admin/chat/conversations/<conversation_id>/messages', methods=['POST'])
@require_admin
def send_chat_message(conversation_id):
    data = request.get_json()
    content = data.get('content')

    # Sauvegarder le message
    message = {
        "conversation_id": ObjectId(conversation_id),
        "sender_id": ObjectId(current_user_id),
        "content": content,
        "created_at": datetime.utcnow(),
        "is_read": False
    }

    result = db.messages.insert_one(message)
    message['id'] = str(result.inserted_id)
    message['sender_id'] = str(message['sender_id'])
    message['conversation_id'] = str(message['conversation_id'])

    # R√©cup√©rer l'autre participant
    conversation = db.conversations.find_one({"_id": ObjectId(conversation_id)})
    recipient_id = None
    for participant in conversation['participants']:
        if str(participant['userId']) != str(current_user_id):
            recipient_id = str(participant['userId'])
            break

    # üîå NOTIFIER VIA WEBSOCKET
    if recipient_id:
        notify_user(recipient_id, 'new_message', {
            'conversation_id': str(conversation_id),
            'message': message
        })

    return jsonify({"success": True, "data": {"message": message}})
```

### POST `/api/admin/chat/invitations`

```python
@app.route('/api/admin/chat/invitations', methods=['POST'])
@require_admin
def create_chat_invitation():
    data = request.get_json()
    to_user_id = data.get('to_user_id')
    message = data.get('message', '')

    # Cr√©er l'invitation
    invitation = {
        "from_user_id": ObjectId(current_user_id),
        "to_user_id": ObjectId(to_user_id),
        "message": message,
        "status": "pending",
        "created_at": datetime.utcnow()
    }

    result = db.chat_invitations.insert_one(invitation)

    # R√©cup√©rer les infos du demandeur
    from_user = db.users.find_one({"_id": ObjectId(current_user_id)})

    invitation_data = {
        "id": str(result.inserted_id),
        "from_user": {
            "id": str(current_user_id),
            "firstname": from_user['firstname'],
            "lastname": from_user['lastname'],
            "email": from_user['email']
        },
        "message": message,
        "status": "pending"
    }

    # üîå NOTIFIER VIA WEBSOCKET
    notify_user(to_user_id, 'new_invitation', {
        'invitation': invitation_data
    })

    return jsonify({"success": True, "data": {"invitation_id": str(result.inserted_id)}})
```

### PUT `/api/admin/chat/invitations/:id/respond`

```python
@app.route('/api/admin/chat/invitations/<invitation_id>/respond', methods=['PUT'])
@require_admin
def respond_to_invitation(invitation_id):
    data = request.get_json()
    action = data.get('action')  # 'accept' or 'reject'

    invitation = db.chat_invitations.find_one({"_id": ObjectId(invitation_id)})

    if action == 'accept':
        # Cr√©er la conversation
        conversation = {
            "participants": [
                {"userId": invitation['from_user_id'], "role": "admin", "status": "active"},
                {"userId": invitation['to_user_id'], "role": "admin", "status": "active"}
            ],
            "status": "accepted",
            "created_at": datetime.utcnow()
        }

        conv_result = db.conversations.insert_one(conversation)

        # Mettre √† jour l'invitation
        db.chat_invitations.update_one(
            {"_id": ObjectId(invitation_id)},
            {"$set": {"status": "accepted"}}
        )

        # üîå NOTIFIER LE DEMANDEUR VIA WEBSOCKET
        notify_user(str(invitation['from_user_id']), 'invitation_accepted', {
            'conversation_id': str(conv_result.inserted_id),
            'participant_id': str(current_user_id)
        })

        return jsonify({"success": True, "data": {"conversation_id": str(conv_result.inserted_id)}})

    else:  # reject
        db.chat_invitations.update_one(
            {"_id": ObjectId(invitation_id)},
            {"$set": {"status": "rejected"}}
        )

        # üîå NOTIFIER LE DEMANDEUR VIA WEBSOCKET
        notify_user(str(invitation['from_user_id']), 'invitation_rejected', {
            'invitation_id': str(invitation_id)
        })

        return jsonify({"success": True})
```

---

## üß™ Test WebSocket

### Test avec Python

```python
import socketio

# Cr√©er un client
sio = socketio.Client()

@sio.on('connect')
def on_connect():
    print('‚úÖ Connect√© au serveur WebSocket')
    # S'authentifier
    sio.emit('authenticate', {'token': 'YOUR_JWT_TOKEN'})

@sio.on('authenticated')
def on_authenticated(data):
    print('üîë Authentifi√©:', data)
    # Rejoindre une conversation
    sio.emit('join_conversation', {'conversation_id': 'conv_123'})

@sio.on('new_message')
def on_new_message(data):
    print('üí¨ Nouveau message:', data)

@sio.on('new_invitation')
def on_new_invitation(data):
    print('üì® Nouvelle invitation:', data)

# Se connecter
sio.connect('http://localhost:5000')
sio.wait()
```

---

## ‚úÖ Checklist d'impl√©mentation

- [ ] Installer `flask-socketio` et `python-socketio`
- [ ] Cr√©er le serveur WebSocket avec CORS
- [ ] Impl√©menter l'√©v√©nement `authenticate`
- [ ] Impl√©menter l'√©v√©nement `join_conversation`
- [ ] Impl√©menter l'√©v√©nement `send_message`
- [ ] Int√©grer WebSocket dans POST `/api/admin/chat/conversations/:id/messages`
- [ ] Int√©grer WebSocket dans POST `/api/admin/chat/invitations`
- [ ] Int√©grer WebSocket dans PUT `/api/admin/chat/invitations/:id/respond`
- [ ] Tester la connexion WebSocket
- [ ] Tester l'envoi/r√©ception de messages en temps r√©el

---

## üîó URLs

**Development** : `ws://localhost:5000/socket.io/`

**Production** : `wss://believable-spontaneity-production.up.railway.app/socket.io/`

---

## üí° Notes importantes

- **Authentification** : Le token JWT doit √™tre envoy√© via l'√©v√©nement `authenticate`
- **Rooms** : Chaque utilisateur a une room personnelle `user_{id}`
- **Conversations** : Chaque conversation a une room `conversation_{id}`
- **Fallback** : Si WebSocket √©choue, le frontend peut utiliser le polling
- **Reconnexion** : Impl√©menter la reconnexion automatique c√¥t√© client

---

**Une fois impl√©ment√©, les messages seront instantan√©s comme WhatsApp !** üöÄüí¨‚ö°
